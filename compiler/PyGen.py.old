import sys
from antlr4 import *
sys.path.append('./')
from grammar.jvmBasicLexer import jvmBasicLexer
from grammar.jvmBasicParser import jvmBasicParser
from grammar.jvmBasicVisitor import jvmBasicVisitor
import logging
from textwrap import indent, dedent

class PyGen(jvmBasicVisitor):
    # PROJECT: Implement the Python generation
    def __init__(self, outfile):
        self.outfile = outfile
        self.labelnum = 0
        self.varnum = 0

    def freshlabel(self):
        self.labelnum += 1
        return f'_l{self.labelnum}'

    def freshvar(self):
        self.varnum += 1
        return f'_t{self.varnum}'
    
    # Visit a parse tree produced by jvmBasicParser#Pro.
    def visitProg(self, ctx:jvmBasicParser.ProgContext):
        for l in ctx.line():
            self.visit(l)
        return None
    
    # Visit a parse tree produced by jvmBasicParser#Line.
    def visitLine(self, ctx:jvmBasicParser.LineContext):
        for a in ctx.amprstmt():
            self.visit(a)
        return None
    
    # Visit a parse tree produced by jvmBasicParser#Line.
    def visitAmprstmt(self, ctx:jvmBasicParser.AmprstmtContext):
        self.visit(ctx.statement())
        return None

    # Visit a parse tree produced by jvmBasicParser#Assignment.
    def visitAssignment(self, ctx:jvmBasicParser.AssignmentContext):
        tempname = self.visit(ctx.a())
        varname = ctx.ID().getText()
        self.outfile.write(dedent(f'''\
        {varname} := {tempname}
        '''))
        return None

    # Visit a parse tree produced by jvmBasicParser#Skip.
    def visitSkip(self, ctx:jvmBasicParser.SkipContext):
        # do nothing
        return None

    # Visit a parse tree produced by jvmBasicParser#If.
    def visitIf(self, ctx:jvmBasicParser.IfContext):
        # create condition
        condition = self.visit(ctx.b())
        # create labels for branching
        elselabel = self.freshlabel()
        endiflabel = self.freshlabel()
        # output code
        self.outfile.write(dedent(f'''\
        if {condition} = 0 goto {elselabel}
        '''))
        self.visit(ctx.s(0))
        self.outfile.write(dedent(f'''\
        goto {endiflabel}
        {elselabel}: '''))
        self.visit(ctx.s(1))
        self.outfile.write(dedent(f'''\
        {endiflabel}: '''))
        return None

    # Visit a parse tree produced by jvmBasicParser#While.
    def visitWhile(self, ctx:jvmBasicParser.jvmBasicContext):
        # create labels for branching
        headlabel = self.freshlabel()
        endlabel = self.freshlabel()
        self.outfile.write(dedent(f'''\
        {headlabel}: '''))
        # create and handle condition
        condition = self.visit(ctx.b())
        self.outfile.write(dedent(f'''\
        if {condition} = 0 goto {endlabel}
        '''))
        self.visit(ctx.s())
        self.outfile.write(dedent(f'''\
        goto {headlabel}
        {endlabel}: '''))
        return None

    # Visit a parse tree produced by jvmBasicParser#Not.
    def visitNot(self, ctx:jvmBasicParser.NotContext):
        originvar = self.visit(ctx.b())
        resultvar = self.freshvar()
        # create labels for branching
        falselabel = self.freshlabel()
        truelabel = self.freshlabel()
        # output code
        self.outfile.write(dedent(f'''\
        if {originvar} = 0 goto {falselabel}
        {resultvar} := 0
        goto {truelabel}
        {falselabel}: {resultvar} := 1
        {truelabel}: '''))
        return resultvar

    # Visit a parse tree produced by jvmBasicParser#And.
    def visitAnd(self, ctx:jvmBasicParser.AndContext):
        var1 = self.visit(ctx.b(0))
        var2 = self.visit(ctx.b(1))
        resultvar = self.freshvar()
        # create labels for branching
        falselabel = self.freshlabel()
        truelabel = self.freshlabel()
        # output code
        self.outfile.write(dedent(f'''\
        if {var1} = 0 goto {falselabel}
        if {var2} = 0 goto {falselabel}
        {resultvar} := 1
        goto {truelabel}
        {falselabel}: {resultvar} := 0
        {truelabel}: '''))
        return resultvar

    # Visit a parse tree produced by jvmBasicParser#Or.
    def visitOr(self, ctx:jvmBasicParser.OrContext):
        var1 = self.visit(ctx.b(0))
        var2 = self.visit(ctx.b(1))
        resultvar = self.freshvar()
        # create labels for branching
        rightlabel = self.freshlabel()
        falselabel = self.freshlabel()
        truelabel = self.freshlabel()
        # output code
        self.outfile.write(dedent(f'''\
        if {var1} = 0 goto {rightlabel}
        {resultvar} := 1
        goto {truelabel}
        {rightlabel}: if {var2} = 0 goto {falselabel}
        {resultvar} := 1
        goto {truelabel}
        {falselabel}: {resultvar} := 0
        {truelabel}: '''))
        return resultvar

    # Visit a parse tree produced by jvmBasicParser#ROp.
    def visitROp(self, ctx:jvmBasicParser.ROpContext):
        var1 = self.visit(ctx.a(0))
        var2 = self.visit(ctx.a(1))
        op = ''
        # get a new temp
        resultvar = self.freshvar()
        # handle op type
        match ctx.op.type:
            case jvmBasicParser.LT:
                op = ctx.LT().getText()
            case jvmBasicParser.LE:
                op = ctx.LE().getText()
            case jvmBasicParser.EQ:
                op = ctx.EQ().getText()
            case jvmBasicParser.GT:
                op = ctx.GT().getText()
            case jvmBasicParser.GE:
                op = ctx.GE().getText()
            case _:
                op = '?'
        # create labels for branching
        truelabel = self.freshlabel()
        endlabel = self.freshlabel()
        # output code
        self.outfile.write(dedent(f'''\
        if {var1} {op} {var2} goto {truelabel}
        {resultvar} := 0
        goto {endlabel}
        {truelabel}: {resultvar} := 1
        {endlabel}: '''))
        return resultvar

    # Visit a parse tree produced by jvmBasicParser#True.
    def visitTrue(self, ctx:jvmBasicParser.TrueContext):
        varname = self.freshvar()
        self.outfile.write(dedent(f'''\
        {varname} := 1
        '''))
        return varname

    # Visit a parse tree produced by jvmBasicParser#False.
    def visitFalse(self, ctx:jvmBasicParser.FalseContext):
        varname = self.freshvar()
        self.outfile.write(dedent(f'''\
        {varname} := 0
        '''))
        return varname

    # Visit a parse tree produced by jvmBasicParser#BParen.
    def visitBParen(self, ctx:jvmBasicParser.BParenContext):
        return self.visit(ctx.b())

    # Visit a parse tree produced by jvmBasicParser#AOp.
    def visitAOp(self, ctx:jvmBasicParser.AOpContext):
        var1 = self.visit(ctx.a(0))
        var2 = self.visit(ctx.a(1))
        op = ''
        # get a new temp
        resultvar = self.freshvar()
        # handle op type
        match ctx.op.type:
            case jvmBasicParser.PLUS:
                op = ctx.PLUS().getText()
            case jvmBasicParser.MINUS:
                op = ctx.MINUS().getText()
            case jvmBasicParser.MULT:
                op = ctx.MULT().getText()
            case jvmBasicParser.DIV:
                op = ctx.DIV().getText()
            case _:
                op = '?'
        # output code
        self.outfile.write(dedent(f'''\
        {resultvar} := {var1} {op} {var2}
        '''))
        # return the new temp
        return resultvar

    # Visit a parse tree produced by jvmBasicParser#Var.
    def visitVar(self, ctx:jvmBasicParser.VarContext):
        tempname = self.freshvar()
        varname = ctx.ID().getText()
        self.outfile.write(dedent(f'''\
        {tempname} := {varname}
        '''))
        return tempname

    # Visit a parse tree produced by jvmBasicParser#Num.
    def visitNum(self, ctx:jvmBasicParser.NumContext):
        tempname = self.freshvar()
        num = ctx.NUM().getText()
        self.outfile.write(dedent(f'''\
        {tempname} := {num}
        '''))
        return tempname

    # Visit a parse tree produced by jvmBasicParser#AParen.
    def visitAParen(self, ctx:jvmBasicParser.AParenContext):
        return self.visit(ctx.a())
    
    # Visit a parse tree produced by jvmBasicParser#Printstmt1.
    def visitPrintstmt1(self, ctx:jvmBasicParser.Printstmt1Context):
        self.outfile.write(dedent(f'''\
        print(f'''))
        self.visit(ctx.printlist())
        self.outfile.write(dedent(f'''\
        )
        '''))
        return
    
    # Visit a parse tree produced by jvmBasicParser#Printlist.
    def visitPrintlist(self, ctx:jvmBasicParser.PrintlistContext):
        for e in ctx.expression():
            self.visit(e)
            if not ctx.COMMA() == None:
                self.outfile.write(dedent(f'''\
                \t'''))
        return

def pygen(input_stream, output_stream):
    lexer = jvmBasicLexer(input_stream)
    stream = CommonTokenStream(lexer)
    parser = jvmBasicParser(stream)
    tree = parser.s()
    if parser.getNumberOfSyntaxErrors() > 0:
        print("syntax errors")
        exit(1)
    else:
        output_stream.write("function main\n")
        # TODO need to collect the local vars, e.g., in the type checker or just run through them first?
        translator = PyGen(output_stream)
        translator.visit(tree)
        output_stream.write("return 0\n")
        output_stream.write("end function\n")
      
def main():
    import sys
    if len(sys.argv) > 1:
        input_stream = FileStream(sys.argv[1])
    else:
        input_stream = StdinStream()
    pygen(input_stream, sys.stdout)

if __name__ == '__main__':
    main()
